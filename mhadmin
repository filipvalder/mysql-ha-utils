#!/bin/sh
# Author: Filip Valder (filip.valder@vsb.cz)
# Date: 9.5.2011
# Description: SHELL script for MySQL backup, restore and service actions
# Name: MySQL High Availability Utilities
# Version: STABLE


# Pre-flight checks
# FreeBSD compatibility
if [ "`uname`" = "FreeBSD" ] ; then
	FIND="gfind"
	STAT_ARGUMENTS="-f %p_%u"
	STAT_CUT_CHARS=5
fi

# Required commands (dependencies)
COMMANDS="cp cut date ${FIND:=find} gzip head lsof mkdir mysql mysqlbinlog mysqlcheck mysqldump pcregrep rev rm sed sort stat tail touch uniq zcat"
for COMMAND in $COMMANDS ; do
	if ! which $COMMAND > /dev/null 2>&1 ; then
		echo "Error: Command $COMMAND not found." 1>&2
		exit 1
	fi
done


# Default configuration
# Global variables
AUTO_CREATE_BACKUP_DIRS=0		# Automatically create subdirectories for MySQL backups across hosting directories. See $WWW_DB_SUBDIR.
CONF_FILE="/usr/local/etc/mhadmin.conf"	# File containing local configuration variables
DEFAULT_CHARACTER_SET="utf8"		# MySQL's default character set
DB_BACKUP_DAYS=30			# Length (in days) for which daily backups are being kept.
DB_BACKUP_DAYS_MONTHLY=180		# Length (in days) for which monthly backups are being kept.
DB_BACKUP_DAYS_WEEKLY=90		# Length (in days) for which weekly backups are being kept.
DB_BACKUP_DIR="/srv/mysqlbackup/"	# Common backup directory containing binlogs and unassigned databases.
DB_MAPPING="s/\.//g"			# Substitution in hosting names for mapping them to database names
LOG_BIN_DIR="/srv/mysql/"		# MySQL's binlog directory
MAX_ALLOWED_PACKET="1GB"		# MySQL's max. allowed packet length
MYSQL_HOST="localhost"			# MySQL host
MYSQL_PASSWORD=""			# MySQL password
MYSQL_USER="root"			# MySQL user
TMP_DIR="/tmp/"				# Temporary directory. It MUST be on a filesystem with enough free space when restoring large databases.
UMASK="006"				# Umask for newly created (temporary) files
WWW_DB_SUBDIR="mysqlbackup"		# Per hosting backup subdirectory
WWW_DIR="/srv/www/"			# Hosting root directory

# Local variables
if [ -r $CONF_FILE ] && ! [ "`stat ${STAT_ARGUMENTS:=-c %a_%u} $CONF_FILE | cut -c ${STAT_CUT_CHARS:=2}-`" = "00_0" ] ; then
	echo "Error: Configuration file $CONF_FILE has NOT limited privileges." 1>&2
	exit 1
elif [ -r $CONF_FILE ] ; then
	. $CONF_FILE
fi

# Generated variables
DAY_OF_MONTH=`date +%d`
DAY_OF_WEEK=`date +%u`
LOCK_FILE="$TMP_DIR/mhadmin.tmp"
MYSQL="mysql --default-character-set=$DEFAULT_CHARACTER_SET -f -h $MYSQL_HOST --max_allowed_packet=$MAX_ALLOWED_PACKET -p$MYSQL_PASSWORD -s -u $MYSQL_USER"
MYSQLBINLOG="mysqlbinlog -D -f --set-charset=$DEFAULT_CHARACTER_SET"
MYSQLCHECK="mysqlcheck --auto-repair --default-character-set=$DEFAULT_CHARACTER_SET -f -h $MYSQL_HOST -p$MYSQL_PASSWORD -s -u $MYSQL_USER"
MYSQLDUMP="mysqldump --add-locks --create-options --default-character-set=$DEFAULT_CHARACTER_SET -K -e -f --hex-blob -h $MYSQL_HOST --max_allowed_packet=$MAX_ALLOWED_PACKET -p$MYSQL_PASSWORD -q --set-charset --single-transaction -u $MYSQL_USER"


# Functions
# Process backups
backup ( ) {
	# Destination directory check
	if [ -z "$DB_BACKUP_DIR" ] || [ "$DB_BACKUP_DIR" = "/" ] || [ ! -d "$DB_BACKUP_DIR" ] ; then
		echo "Error: Target backup directory $DB_BACKUP_DIR is not valid." 1>&2
		rm $LOCK_FILE
		exit 1
	fi
	# Backup type/length
	TYPE="$1"
	# Backup binlogs only
	if ! [ "$TYPE" = "dumps" ] ; then
		echo "FLUSH LOGS" | $MYSQL
		LOG_BIN_LAST=`lsof -w | pcregrep "^mysqld\s+\S+\s+\S+\s+\S+w\s+.*\Wmysql-bin.\d{6}$" | rev | cut -d "." -f 1 | rev | sort -n | tail -n 1`
		for LOG_BIN in `$FIND $LOG_BIN_DIR -name "mysql-bin.[0-9][0-9][0-9][0-9][0-9][0-9]" -printf "%f\n" 2> /dev/null | sort -n | cut -d "." -f 2` ; do
			if [ $LOG_BIN -lt $LOG_BIN_LAST ] ; then
				DATETIME=`date +%F.%T`
				cd $LOG_BIN_DIR && [ ! -f $DB_BACKUP_DIR/_binlog.*.*.$LOG_BIN.gz ] && cp -p mysql-bin.$LOG_BIN $DB_BACKUP_DIR/_binlog.$DATETIME.$LOG_BIN && gzip $DB_BACKUP_DIR/_binlog.$DATETIME.$LOG_BIN
			fi
		done
	fi
	# Backup dumps only
	if ! [ "$TYPE" = "logs" ] ; then
		# Add weekly/monthly prefix
		[ ! -f $DB_BACKUP_DIR/_checkpoint.weekly ] && touch $DB_BACKUP_DIR/_checkpoint.weekly
		$FIND $DB_BACKUP_DIR/_checkpoint.weekly -mtime +7 && touch $DB_BACKUP_DIR/_checkpoint.weekly && PREFIX="_weekly."
		[ ! -f $DB_BACKUP_DIR/_checkpoint.monthly ] && touch $DB_BACKUP_DIR/_checkpoint.monthly
		$FIND $DB_BACKUP_DIR/_checkpoint.monthly -mtime +30 && touch $DB_BACKUP_DIR/_checkpoint.monthly && PREFIX="_monthly."
		# Search for (sub)databases which correspond with their hosting name and backup them
		for HOSTING in `$FIND $WWW_DIR -maxdepth 1 -mindepth 1 -name "[^._]*" -type d -printf "%f " 2> /dev/null` ; do
			if [ $AUTO_CREATE_BACKUP_DIRS -eq 1 ] || [ -d "$WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/" ] ; then
				DATABASE=`echo $HOSTING | sed "$DB_MAPPING"`
				DATETIME=`date +%F.%T`
				mkdir -p $WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/ && $MYSQLDUMP $DATABASE | gzip > $WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/$PREFIX$DATABASE.$DATETIME.sql.gz
				DATABASE_LIST="$DATABASE_LIST $DATABASE"
				for DATABASE in `echo -e "SHOW DATABASES LIKE '$DATABASE\_%'" | $MYSQL` ; do
					DATETIME=`date +%F.%T`
					$MYSQLDUMP $DATABASE | gzip > $WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/$PREFIX$DATABASE.$DATETIME.sql.gz
					DATABASE_LIST="$DATABASE_LIST $DATABASE"
				done
			fi
		done
		# Backup unassigned databases to the common backup directory
		for DATABASE in `echo "SHOW DATABASES" | $MYSQL | pcregrep -v "^information_schema$"` ; do
			if ! echo "$DATABASE_LIST " | pcregrep " $DATABASE " ; then
				DATETIME=`date +%F.%T`
				mkdir -p $DB_BACKUP_DIR && $MYSQLDUMP $DATABASE | gzip > $DB_BACKUP_DIR/$PREFIX$DATABASE.$DATETIME.sql.gz
			fi
		done
	fi
	# Remove old backups (incl. binlogs) in hosting subdirectories and the common backup directory
	$FIND $WWW_DIR/*/$WWW_DB_SUBDIR/ $DB_BACKUP_DIR -maxdepth 1 -mtime +$DB_BACKUP_DAYS -name "[^._]*" -type f -delete 2> /dev/null
	$FIND $WWW_DIR/*/$WWW_DB_SUBDIR/ $DB_BACKUP_DIR -maxdepth 1 -mtime +$DB_BACKUP_DAYS -name "_binlog.*" -type f -delete 2> /dev/null
	$FIND $WWW_DIR/*/$WWW_DB_SUBDIR/ $DB_BACKUP_DIR -maxdepth 1 -mtime +$DB_BACKUP_DAYS_MONTHLY -name "_monthly.*" -type f -delete 2> /dev/null
	$FIND $WWW_DIR/*/$WWW_DB_SUBDIR/ $DB_BACKUP_DIR -maxdepth 1 -mtime +$DB_BACKUP_DAYS_WEEKLY -name "_weekly.*" -type f -delete 2> /dev/null
}

# Process restore
restore ( ) {
	# Arguments
	DATABASE="$1"
	DATE="$2"
	TIME="$3"
	# Args generation
	DATABASE_BACKUP=`echo ${DATABASE}_$DATE$TIME | sed "s/[-:]//g"`
	HOSTING=`echo $DATABASE | cut -d "_" -f 1`
	STOP_DATETIME="$DATE $TIME"
	# Modify timestamp on the lockfile
	touch -t `echo $DATE$TIME | sed -e "s/\([0-9][0-9]\)$/.\1/" -e "s/[-:]//g"` $LOCK_FILE
	# Search for available dumps
	DUMP=`$FIND \
		$WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/$DATABASE.*.*.sql.gz \
		$WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/_monthly.$DATABASE.*.*.sql.gz \
		$WWW_DIR/$HOSTING/$WWW_DB_SUBDIR/_weekly.$DATABASE.*.*.sql.gz \
		$DB_BACKUP_DIR/$DATABASE.*.*.sql.gz \
		$DB_BACKUP_DIR/_monthly.$DATABASE.*.*.sql.gz \
		$DB_BACKUP_DIR/_weekly.$DATABASE.*.*.sql.gz \
	! -newer $LOCK_FILE -printf "%T@ %p\n" 2> /dev/null | sort -n | tail -n 1 | cut -d " " -f 2-`
	# Exit when no dump is available
	if [ -z "$DUMP" ] ; then
		echo "Error: No dump for database $DATABASE found." 1>&2
		rm $LOCK_FILE
		exit 1
	fi
	START_DATETIME=`echo $DUMP | sed "s/.*\.\([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]\)\.\([0-9][0-9]:[0-9][0-9]:[0-9][0-9]\)\.sql\.gz/\1 \2/"`
	# Search for first required binlog
	BINLOG_FIRST=`$FIND \
		$DB_BACKUP_DIR/_binlog.*.*.*.gz \
		$LOG_BIN_DIR/mysql-bin.[0-9][0-9][0-9][0-9][0-9][0-9] \
	-newer $DUMP -printf "%T@ %p\n" 2> /dev/null | sort -n | head -n 1 | cut -d " " -f 2-`
	# Search for last required binlog
	BINLOG_LAST=`$FIND \
		$DB_BACKUP_DIR/_binlog.*.*.*.gz \
		$LOG_BIN_DIR/mysql-bin.[0-9][0-9][0-9][0-9][0-9][0-9] \
	-newer $LOCK_FILE -printf "%T@ %p\n" 2> /dev/null | sort -n | head -n 1 | cut -d " " -f 2-`
	# Generate args in order to search for intermediate binlogs
	if [ -n "$BINLOG_FIRST" ] && [ -n "$BINLOG_LAST" ] ; then
		ARGUMENTS="-newer $BINLOG_FIRST -a ! -newer $BINLOG_LAST"
	elif [ -n "$BINLOG_FIRST" ] ; then
		ARGUMENTS="-newer $BINLOG_FIRST"
	elif [ -n "$BINLOG_LAST" ] ; then
		ARGUMENTS="! -newer $BINLOG_LAST"
	else
		ARGUMENTS=""
	fi
	# Search for intermediate binlogs
	BINLOGS=`$FIND \
		$DB_BACKUP_DIR/_binlog.*.*.*.gz \
		$LOG_BIN_DIR/mysql-bin.[0-9][0-9][0-9][0-9][0-9][0-9] \
	$ARGUMENTS -printf "%T@ %p\n" 2> /dev/null | sort -n | cut -d " " -f 2-`
	# Create list of all required binlogs
	BINLOG_LIST=`echo -e "$BINLOG_FIRST\n$BINLOGS\n$BINLOG_LAST" | sort | uniq`
	if [ -z "$BINLOG_LIST" ] ; then
		echo "Warning: No binlog found." 1>&2
	fi
	# Find an SQL query for backup database creation and execute it
	echo "SHOW CREATE DATABASE \`${DATABASE}\`" | $MYSQL | sed -e "s/^$DATABASE	//" -e "s/\`$DATABASE\`/\`$DATABASE_BACKUP\`/" | $MYSQL
	echo -n "Restoring database backup: $DUMP"
	zcat $DUMP | $MYSQL $DATABASE_BACKUP
	# Restore binlogs
	echo -e ".\nRestoring binlogs:"
	for BINLOG in $BINLOG_LIST ; do
		BINLOG_FILE=$BINLOG
		# Avoid restoring duplicate binlogs
		[ -f $LOG_BIN_DIR/`echo $BINLOG_FILE | sed "s/.*\.\([0-9][0-9][0-9][0-9][0-9][0-9]\)\.gz$/mysql-bin.\1/"` ] && continue
		# Find out a file type containing binlog
		if file -b $BINLOG_FILE | pcregrep "^gzip compressed data" > /dev/null ; then
			zcat $BINLOG_FILE > $LOCK_FILE
			BINLOG_FILE=$LOCK_FILE
		fi
		# Find out a file type containing binlog
		if file -b $BINLOG_FILE | pcregrep "^MySQL replication log" > /dev/null ; then
			$MYSQLBINLOG -d $DATABASE --start-datetime="$START_DATETIME" --stop-datetime="$STOP_DATETIME" $BINLOG_FILE | pcregrep -v "^use $DATABASE" | $MYSQL $DATABASE_BACKUP
			echo "$BINLOG"
		else
			echo "Warning: Binlog $BINLOG is not valid." 1>&2
		fi
	done
	echo "."
}

# Process service
vacuum ( ) {
	# Service type/length
	LENGTH="$1"
	# Error counter
	ERROR_COUNTER=0
	# Args generation
	if [ "$LENGTH" = "quick" ] ; then
		ARGUMENTS="--quick"
	else
		ARGUMENTS="--analyze --extended --optimize"
	fi
	# Loop through all databases
	for DATABASE in `echo "SHOW DATABASES" | $MYSQL | pcregrep -v "^information_schema$"` ; do
		# Loop through all tables
		for TABLE in `echo "USE $DATABASE; SHOW TABLES" | $MYSQL` ; do
			# Execute check command
			$MYSQLCHECK $ARGUMENTS $DATABASE $TABLE || let ERROR_COUNTER=ERROR_COUNTER+1
		done
	done
	# Error status
	[ $ERROR_COUNTER -eq 0 ] || exit 1
}

# Show name and version
version ( ) {
	# Grep this script
	NAME=`pcregrep "^# Name: " $0 | head -n 1 | sed "s/^# Name: //"`
	VERSION=`pcregrep "^# Version: " $0 | head -n 1 | sed "s/^# Version: //"`
	# Show name and version
	echo "$NAME v$VERSION"
}


# Main program
# Set ``umask'' for newly created files
umask $UMASK
# Lockfile check
if [ -f $LOCK_FILE ] ; then
	echo "Error: Lockfile $LOCK_FILE exists." 1>&2
	exit 1
else
	touch $LOCK_FILE
fi
# Check arguments
case $1 in
	backup)
		backup $2
	;;
	restore)
		restore $2 $3 $4
	;;
	vacuum)
		vacuum $2
	;;
	version)
		version
	;;
	*)
		[ ! -z "$1" ] && echo "Unknown command: $1"
		echo "`version`

Available commands:
    backup [dumps|logs]             Perform full database backups
                                    [dumps only|binlogs only]
    restore database Y-m-d H:M:S    Restore a database as of time/date
    vacuum [quick]                  Perform full service on all tables
                                    of all databases [checks/repairs only]
    version                         Show this script's name and version"
	;;
esac
# Remove lockfile
rm $LOCK_FILE
# Exit status
exit 0
